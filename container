#!/usr/bin/env ruby

require 'bundler/setup'
require 'childprocess'

require_relative 'lib_c'

HOSTNAME = 'container'.freeze

def must(exit_code)
  unless exit_code == 0
    $stderr.puts caller
    abort "exit code: #{exit_code}; errno: #{Fiddle.last_error}"
  end
end

def run(*args)
  puts "run: Running #{args.inspect} as PID #{Process.pid}"

  process = ChildProcess.build(__FILE__, 'child', *args)
  process.io.inherit!
  process.start
  process.wait

  abort "run: exit code #{process.exit_code}" unless process.exit_code == 0
end

def child(*args)
  puts "child: Running #{args.inspect} as PID #{Process.pid}"

  must(LibC.unshare(LibC::CLONE_NEWUTS | LibC::CLONE_NEWPID))
  must(LibC.sethostname(HOSTNAME, HOSTNAME.length))

  process = ChildProcess.build(__FILE__, 'grandchild', *args)
  process.io.inherit!
  process.start
  process.wait

  abort "child: exit code #{process.exit_code}" unless process.exit_code == 0
end

def grandchild(*args)
  puts "grandchild: Running #{args.inspect} as PID #{Process.pid}"

  process = ChildProcess.build(*args)
  process.io.inherit!
  process.start
  process.wait

  abort "grandchild: exit code #{process.exit_code}" unless process.exit_code == 0
end

args = ARGV
type = args.shift
case type
when 'run'
  run(*args)
when 'child'
  child(*args)
when 'grandchild'
  grandchild(*args)
else
  abort "Unknown type: #{type}"
end
